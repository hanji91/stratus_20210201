// Generated by stratus_hls 19.10-p100  (91500.011111)
// Fri Jan 15 16:39:43 2021
// from float2fix.cpp

`timescale 1ps / 1ps

      
module float2fix(clk, rstn, src_valid, src, dst_valid, dst);

      input clk;
      input rstn;
      input src_valid;
      input [31:0] src;
      output dst_valid;
      reg dst_valid;
      output [31:0] dst;
      reg [31:0] dst;
      reg[31:0] float2fix_N_Mux_32_2_12_4_12_out1;
      wire[7:0] float2fix_MuxSubi127u8i0u1_4_10_in2;
      reg src_valid_1d;
      reg[31:0] r_in_data;
      wire float2fix_And_1Ux1U_1U_4_9_in1;
      wire float2fix_And_1Ux1U_1U_4_9_out1;
      reg a_s;
      reg[7:0] float2fix_MuxSubi127u8i0u1_4_10_out1;
      reg[23:0] float2fix_MuxCati0Catu23i1i0u1_4_11_out1_slice;
      reg[7:0] a_e;
      reg[23:0] a_m_slice;
      /*signed*/wire[4:0] float2fix_Subu5i31_1_14_out1;
      wire[31:0] float2fix_RightShift_32Ux5U_32U_4_17_out1;
      reg src_valid_2d;
      wire float2fix_And_1Ux1U_1U_4_16_out1;
      wire float2fix_Gti31s9_1_13_out1;
      wire float2fix_Not_1U_1U_4_15_out1;
      reg[31:0] float2fix_Muxu32i0u1_4_18_out1;
      reg[31:0] float2fix_N_Mux_32_2_12_4_7_out1;
      reg r_a_s;
      /*signed*/wire[31:0] float2fix_Add2i1s32_4_6_out1;
      /*signed*/wire[31:0] float2fix_NotBit_32U_32S_4_5_out1;
      wire float2fix_And_1Ux1U_1U_4_4_out1;
      wire float2fix_Not_1U_1U_4_3_out1;
      reg r_max_sig;
      wire float2fix_Or_1Ux1U_1U_4_1_out1;
      reg[31:0] r_a_m;
      wire float2fix_Or_1Ux1U_1U_4_1_in1;
      reg[31:0] float2fix_Muxu32i0u1_4_8_out1;
      reg src_valid_3d;

         // rtl_process:float2fix/drive_dst_valid
         // Sharing or Control mux
         // Sharing/Controlling 2 operation(s) on drive_dst_valid
         // at: float2fix.h:127:7
         // at: float2fix.h:130:7
         always @(posedge clk or negedge rstn)
          begin :drive_dst_valid
            if (rstn == 1'b0) begin
               // op:_dst_valid/OP0
               dst_valid <= 1'd0;
            end
            else begin
               // op:_dst_valid/OP2
               dst_valid <= src_valid_3d;
            end
         end

         // rtl_process:float2fix/drive_dst
         // Sharing or Control mux
         // Sharing/Controlling 2 operation(s) on drive_dst
         // at: float2fix.h:106:7
         // at: float2fix.h:120:7
         always @(posedge clk or negedge rstn)
          begin :drive_dst
            if (rstn == 1'b0) begin
               // op:_dst/OP3
               dst <= 32'd0000000000;
            end
            else begin
               // op:_dst/OP18
               dst <= float2fix_Muxu32i0u1_4_8_out1;
            end
         end

         // rtl_process:float2fix/drive_float2fix_Or_1Ux1U_1U_4_1_in1
         // Sharing or Control mux
         // Sharing/Controlling 1 operation(s) on drive_float2fix_Or_1Ux1U_1U_4_1_in1
         // at: float2fix.h:114:26
         assign float2fix_Or_1Ux1U_1U_4_1_in1 = r_a_m[31];

         // rtl_instance:float2fix/float2fix_Or_1Ux1U_1U_4_1
         // Resource=float2fix_Or_1Ux1U_1U_4, Function=or : Inputs=1,1 Outputs=1
         // Implements 1 operation(s)
         // at: float2fix.h:112:14
         assign float2fix_Or_1Ux1U_1U_4_1_out1 = r_max_sig | float2fix_Or_1Ux1U_1U_4_1_in1;

         // rtl_instance:float2fix/float2fix_Not_1U_1U_4_3
         // Resource=float2fix_Not_1U_1U_4, Function=not : Inputs=1 Outputs=1
         // Implements 1 operation(s)
         // at: float2fix.h:110:14
         assign float2fix_Not_1U_1U_4_3_out1 = !float2fix_Or_1Ux1U_1U_4_1_out1;

         // rtl_instance:float2fix/float2fix_And_1Ux1U_1U_4_4
         // Resource=float2fix_And_1Ux1U_1U_4, Function=and : Inputs=1,1 Outputs=1
         // Implements 1 operation(s)
         // at: float2fix.h:108:15
         assign float2fix_And_1Ux1U_1U_4_4_out1 = float2fix_Not_1U_1U_4_3_out1 & src_valid_3d;

         // rtl_instance:float2fix/float2fix_NotBit_32U_32S_4_5
         // Resource=float2fix_NotBit_32U_32S_4, Function=not : Inputs=32 Outputs=32S
         // Implements 1 operation(s)
         // at: float2fix.h:118:14
         assign float2fix_NotBit_32U_32S_4_5_out1 = ~r_a_m;

         // rtl_instance:float2fix/float2fix_Add2i1s32_4_6
         // Resource=float2fix_Add2i1s32_4, Function=add : Inputs=32S Outputs=32S
         // Implements 1 operation(s)
         // at: float2fix.h:118:29
         assign float2fix_Add2i1s32_4_6_out1 = float2fix_NotBit_32U_32S_4_5_out1 + 32'd0000000001;

         // rtl_instance:float2fix/float2fix_N_Mux_32_2_12_4
         always @(r_a_m or r_a_s or float2fix_Add2i1s32_4_6_out1)
          begin :float2fix_N_Mux_32_2_12_4_7
            if (r_a_s) begin
               float2fix_N_Mux_32_2_12_4_7_out1 = float2fix_Add2i1s32_4_6_out1;
            end
            else begin
               float2fix_N_Mux_32_2_12_4_7_out1 = r_a_m;
            end
         end

         // rtl_instance:float2fix/float2fix_Muxu32i0u1_4
         always @(float2fix_And_1Ux1U_1U_4_4_out1 or float2fix_N_Mux_32_2_12_4_7_out1)
          begin :float2fix_Muxu32i0u1_4_8
            if (float2fix_And_1Ux1U_1U_4_4_out1) begin
               float2fix_Muxu32i0u1_4_8_out1 = float2fix_N_Mux_32_2_12_4_7_out1;
            end
            else begin
               float2fix_Muxu32i0u1_4_8_out1 = 32'd0000000000;
            end
         end

         // rtl_process:float2fix/drive_r_a_m
         // Sharing or Control mux
         // Sharing/Controlling 4 operation(s) on drive_r_a_m
         // at: float2fix.h:114:14
         // at: float2fix.h:118:15
         // at: float2fix.h:89:7
         // at: float2fix.h:99:7
         always @(posedge clk or negedge rstn)
          begin :drive_r_a_m
            if (rstn == 1'b0) begin
               // op:_r_a_m/OP69
               r_a_m <= 32'd0000000000;
            end
            else begin
               // op:_r_a_m/OP78
               r_a_m <= float2fix_Muxu32i0u1_4_18_out1;
            end
         end

         // rtl_instance:float2fix/float2fix_Not_1U_1U_4_15
         // Resource=float2fix_Not_1U_1U_4, Function=not : Inputs=1 Outputs=1
         // Implements 1 operation(s)
         // at: float2fix.h:95:14
         assign float2fix_Not_1U_1U_4_15_out1 = !float2fix_Gti31s9_1_13_out1;

         // rtl_instance:float2fix/float2fix_And_1Ux1U_1U_4_16
         // Resource=float2fix_And_1Ux1U_1U_4, Function=and : Inputs=1,1 Outputs=1
         // Implements 1 operation(s)
         // at: float2fix.h:92:15
         assign float2fix_And_1Ux1U_1U_4_16_out1 = float2fix_Not_1U_1U_4_15_out1 & src_valid_2d;

         // rtl_instance:float2fix/float2fix_RightShift_32Ux5U_32U_4_17
         // Resource=float2fix_RightShift_32Ux5U_32U_4, Function=rs : Inputs=32,5 Outputs=32
         // Implements 1 operation(s)
         // at: float2fix.h:99:26
         assign float2fix_RightShift_32Ux5U_32U_4_17_out1 = {a_m_slice, 8'd000} >> float2fix_Subu5i31_1_14_out1;

         // rtl_instance:float2fix/float2fix_Muxu32i0u1_4
         always @(float2fix_And_1Ux1U_1U_4_16_out1 or float2fix_RightShift_32Ux5U_32U_4_17_out1)
          begin :float2fix_Muxu32i0u1_4_18
            if (float2fix_And_1Ux1U_1U_4_16_out1) begin
               float2fix_Muxu32i0u1_4_18_out1 = float2fix_RightShift_32Ux5U_32U_4_17_out1;
            end
            else begin
               float2fix_Muxu32i0u1_4_18_out1 = 32'd0000000000;
            end
         end

         // rtl_instance:float2fix/float2fix_Gti31s9_1_13
         // Resource=float2fix_Gti31s9_1, Function=gt : Inputs=9S Outputs=1
         // Implements 1 operation(s)
         // at: float2fix.h:81:39
         assign float2fix_Gti31s9_1_13_out1 = {1'b0, a_e} > 9'd031;

         // rtl_instance:float2fix/float2fix_Subu5i31_1_14
         // Resource=float2fix_Subu5i31_1, Function=sub : Inputs=5 Outputs=5S
         // Implements 1 operation(s)
         // at: float2fix.h:83:22
         assign float2fix_Subu5i31_1_14_out1 = 5'd31 - a_e[4:0];

         // rtl_process:float2fix/drive_a_m_slice
         // Sharing or Control mux
         // Sharing/Controlling 3 operation(s) on drive_a_m_slice
         // at: float2fix.h:62:7
         // at: float2fix.h:72:7
         // at: float2fix.h:99:15
         always @(posedge clk or negedge rstn)
          begin :drive_a_m_slice
            if (rstn == 1'b0) begin
               // op:_a_m_e_s/OP33
               a_m_slice <= 24'd00000000;
            end
            else begin
               // op:_a_m_e_s/OP43
               a_m_slice <= float2fix_MuxCati0Catu23i1i0u1_4_11_out1_slice;
            end
         end

         // rtl_process:float2fix/drive_a_e
         // Sharing or Control mux
         // Sharing/Controlling 3 operation(s) on drive_a_e
         // at: float2fix.h:63:7
         // at: float2fix.h:73:7
         // at: float2fix.h:83:24
         always @(posedge clk or negedge rstn)
          begin :drive_a_e
            if (rstn == 1'b0) begin
               // op:_a_m_e_s/OP34
               a_e <= 8'd000;
            end
            else begin
               // op:_a_m_e_s/OP41
               a_e <= float2fix_MuxSubi127u8i0u1_4_10_out1;
            end
         end

         // rtl_process:float2fix/drive_a_s
         // Sharing or Control mux
         // Sharing/Controlling 3 operation(s) on drive_a_s
         // at: float2fix.h:64:7
         // at: float2fix.h:74:7
         // at: float2fix.h:43:15
         always @(posedge clk or negedge rstn)
          begin :drive_a_s
            if (rstn == 1'b0) begin
               // op:_a_m_e_s/OP35
               a_s <= 1'd0;
            end
            else begin
               // op:_a_m_e_s/OP39
               a_s <= float2fix_And_1Ux1U_1U_4_9_out1;
            end
         end

         // rtl_process:float2fix/drive_float2fix_And_1Ux1U_1U_4_9_in1
         // Sharing or Control mux
         // Sharing/Controlling 1 operation(s) on drive_float2fix_And_1Ux1U_1U_4_9_in1
         // at: float2fix.h:74:29
         assign float2fix_And_1Ux1U_1U_4_9_in1 = r_in_data[31];

         // rtl_instance:float2fix/float2fix_And_1Ux1U_1U_4_9
         // Resource=float2fix_And_1Ux1U_1U_4, Function=and : Inputs=1,1 Outputs=1
         // Implements 1 operation(s)
         // at: float2fix.h:66:10
         assign float2fix_And_1Ux1U_1U_4_9_out1 = src_valid_1d & float2fix_And_1Ux1U_1U_4_9_in1;

         // rtl_process:float2fix/drive_float2fix_MuxSubi127u8i0u1_4_10_in2
         // Sharing or Control mux
         // Sharing/Controlling 1 operation(s) on drive_float2fix_MuxSubi127u8i0u1_4_10_in2
         // at: float2fix.h:73:29
         assign float2fix_MuxSubi127u8i0u1_4_10_in2 = r_in_data[30:23];

         // rtl_instance:float2fix/float2fix_MuxSubi127u8i0u1_4
         always @(src_valid_1d or float2fix_MuxSubi127u8i0u1_4_10_in2)
          begin :float2fix_MuxSubi127u8i0u1_4_10
            if (src_valid_1d) begin
               float2fix_MuxSubi127u8i0u1_4_10_out1 = float2fix_MuxSubi127u8i0u1_4_10_in2 - 8'd127;
            end
            else begin
               float2fix_MuxSubi127u8i0u1_4_10_out1 = 8'd000;
            end
         end

         // rtl_instance:float2fix/float2fix_MuxCati0Catu23i1i0u1_4
         always @(src_valid_1d or r_in_data[22:0])
          begin :float2fix_MuxCati0Catu23i1i0u1_4_11
            if (src_valid_1d) begin
               float2fix_MuxCati0Catu23i1i0u1_4_11_out1_slice = {1'b1, r_in_data[22:0]};
            end
            else begin
               float2fix_MuxCati0Catu23i1i0u1_4_11_out1_slice = 24'd00000000;
            end
         end

         // rtl_process:float2fix/drive_r_in_data
         // Sharing or Control mux
         // Sharing/Controlling 4 operation(s) on drive_r_in_data
         // at: float2fix.h:74:13
         // at: float2fix.h:52:7
         // at: float2fix.h:55:7
         always @(posedge clk or negedge rstn)
          begin :drive_r_in_data
            if (rstn == 1'b0) begin
               // op:_r_in_data/OP50
               r_in_data <= 32'd0000000000;
            end
            else begin
               // op:_r_in_data/OP56
               r_in_data <= float2fix_N_Mux_32_2_12_4_12_out1;
            end
         end

         // rtl_instance:float2fix/float2fix_N_Mux_32_2_12_4
         always @(src or src_valid or r_in_data)
          begin :float2fix_N_Mux_32_2_12_4_12
            if (src_valid) begin
               float2fix_N_Mux_32_2_12_4_12_out1 = src;
            end
            else begin
               float2fix_N_Mux_32_2_12_4_12_out1 = r_in_data;
            end
         end

         // rtl_process:float2fix/drive_src_valid_3d
         // Sharing or Control mux
         // Sharing/Controlling 4 operation(s) on drive_src_valid_3d
         // at: float2fix.h:130:19
         // at: float2fix.h:108:15
         // at: float2fix.h:34:7
         // at: float2fix.h:42:7
         always @(posedge clk or negedge rstn)
          begin :drive_src_valid_3d
            if (rstn == 1'b0) begin
               // op:_delay/OP88
               src_valid_3d <= 1'd0;
            end
            else begin
               // op:_delay/OP101
               src_valid_3d <= src_valid_2d;
            end
         end

         // rtl_process:float2fix/drive_r_max_sig
         // Sharing or Control mux
         // Sharing/Controlling 3 operation(s) on drive_r_max_sig
         // at: float2fix.h:112:14
         // at: float2fix.h:37:7
         // at: float2fix.h:45:7
         always @(posedge clk or negedge rstn)
          begin :drive_r_max_sig
            if (rstn == 1'b0) begin
               // op:_delay/OP91
               r_max_sig <= 1'd0;
            end
            else begin
               // op:_delay/OP104
               r_max_sig <= float2fix_Gti31s9_1_13_out1;
            end
         end

         // rtl_process:float2fix/drive_r_a_s
         // Sharing or Control mux
         // Sharing/Controlling 3 operation(s) on drive_r_a_s
         // at: float2fix.h:117:10
         // at: float2fix.h:35:7
         // at: float2fix.h:43:7
         always @(posedge clk or negedge rstn)
          begin :drive_r_a_s
            if (rstn == 1'b0) begin
               // op:_delay/OP89
               r_a_s <= 1'd0;
            end
            else begin
               // op:_delay/OP102
               r_a_s <= a_s;
            end
         end

         // rtl_process:float2fix/drive_src_valid_2d
         // Sharing or Control mux
         // Sharing/Controlling 4 operation(s) on drive_src_valid_2d
         // at: float2fix.h:92:15
         // at: float2fix.h:33:7
         // at: float2fix.h:41:7
         always @(posedge clk or negedge rstn)
          begin :drive_src_valid_2d
            if (rstn == 1'b0) begin
               // op:_delay/OP87
               src_valid_2d <= 1'd0;
            end
            else begin
               // op:_delay/OP100
               src_valid_2d <= src_valid_1d;
            end
         end

         // rtl_process:float2fix/drive_src_valid_1d
         // Sharing or Control mux
         // Sharing/Controlling 4 operation(s) on drive_src_valid_1d
         // at: float2fix.h:66:15
         // at: float2fix.h:32:7
         // at: float2fix.h:40:7
         always @(posedge clk or negedge rstn)
          begin :drive_src_valid_1d
            if (rstn == 1'b0) begin
               // op:_delay/OP86
               src_valid_1d <= 1'd0;
            end
            else begin
               // op:_delay/OP99
               src_valid_1d <= src_valid;
            end
         end


endmodule


